#include <fstream>
#include <vector>

using namespace std;
ifstream in;
ofstream out;

int max(int a, int b) {      //‘ункци€, котора€ возвращает большее число
	if (a >= b) return a;
	else return b;
}

int main() {
	in.open("turtle.in");
	int h, w;
	in >> h >> w;
	vector < vector <int> > a(h, vector <int>(w));
	for (int i = h - 1; i >= 0; i--) {		//заполн€ем двумерный массив, так как в массиве верхн€€ строчка €вл€етс€ последней(нумераци€ элементов идЄт снизу вверх),
		for (int j = 0; j < w; j++) {		//а поступает на ввод она первой, то необходимо начинать запись с h-1 строки, то есть сверху вниз
			in >> a[i][j];
		}
	}
	in.close();
	for (int i = 1; i < h; i++) {
		a[i][0] += a[i - 1][0];		// считаем все элементы первого столбика, так как в них можно попасть только 1 путем ид€ вверх от начала
	}
	for (int j = 1; j < w; j++) {
		a[0][j] += a[0][j - 1];		//аналогично первому столбику поступаем с первой строчкой(та, что снизу) по той же причине
	}
	for (int i = 1; i < h; i++) {
		for (int j = 1; j < w; j++) {
			a[i][j] += max(a[i - 1][j], a[i][j - 1]);		//начина€ с элемента 1 1(птому что с него начинаютс€ непройденные клетки)
		}                                                   //считаем наибольший элемент слева или снизу, так как только из них можно сюда попасть
	}                                                       //таким образом находим наибольшее значение дл€ каждого элемента таблицы
	out.open("turtle.out");
	out << a[h - 1][w - 1];                                //выводим -1, так как начинали с нулевого элемента
	out.close();
	return 0;
}
